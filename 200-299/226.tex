\section{226 --- Invert Binary Tree}
Invert a binary tree.

\paragraph{Example:}
\begin{flushleft}


\textbf{Input:}
\begin{figure}[H]
\begin{tikzpicture}
[mynode/.style={draw,circle,minimum size=5mm, fill=gray!20!}]
\node(){};
\node[mynode](1) {4};
\node[mynode](2)[below=8mm of 1, xshift=-11mm] {2};
\node[mynode](3)[below=8mm of 1, xshift=11mm] {7};
\node[mynode](4)[below=8mm of 2, xshift=-6mm] {1};
\node[mynode](5)[below=8mm of 2, xshift=6mm] {3};
\node[mynode](6)[below=8mm of 3, xshift=-6mm] {6};
\node[mynode](7)[below=8mm of 3, xshift=6mm] {9};
\draw (1) -- (2);
\draw (1) -- (3);
\draw (2) -- (4);
\draw (2) -- (5);
\draw (3) -- (6);
\draw (3) -- (7);
\end{tikzpicture}
\end{figure}
\textbf{Output:}
\begin{figure}[H]
\begin{tikzpicture}
[mynode/.style={draw,circle,minimum size=5mm, fill=gray!20!}]
\node(){};
\node[mynode](1) {4};
\node[mynode](2)[below=8mm of 1, xshift=-11mm] {7};
\node[mynode](3)[below=8mm of 1, xshift=11mm] {2};
\node[mynode](4)[below=8mm of 2, xshift=-6mm] {9};
\node[mynode](5)[below=8mm of 2, xshift=6mm] {6};
\node[mynode](6)[below=8mm of 3, xshift=-6mm] {3};
\node[mynode](7)[below=8mm of 3, xshift=6mm] {1};
\draw (1) -- (2);
\draw (1) -- (3);
\draw (2) -- (4);
\draw (2) -- (5);
\draw (3) -- (6);
\draw (3) -- (7);
\end{tikzpicture}
\end{figure}
\end{flushleft}
\subsection{Recursion}
\begin{CJK*}{UTF8}{gbsn}
对于每一个节点，都是相同的操作，
\begin{itemize}
\item 获得当前节点的左右子节点
\item 分别对左右子节点进行\textbf{invert}操作
\item 将当前节点的左子节点指向invert后的右子树
\item 将当前节点的右子节点指向invert后的左子数。
\end{itemize}
\end{CJK*}
\setcounter{algorithm}{0}
\begin{algorithm}[H]
\caption{Recursion}
\begin{algorithmic}[1]
\Procedure{Invert}{$T$}
\If{$T$ is an empty node}
\State \Return $T$
\EndIf
\State $\star$ Set $l$ equal to $T$'s left node
\State $\star$ Set $r$ equal to $T$'s right node
\State $\star$ Set $T$'s left node to the inverted $r$
\State $\star$ Set $T$'s right node to the inverted $l$
\State \Return $T$
\EndProcedure
\end{algorithmic}
\end{algorithm}
\setcounter{lstlisting}{0}
\begin{lstlisting}[style=customc, caption={Recursion}]
TreeNode* invertTree( TreeNode* root )
{

    if( !root )
    {
        return root;
    }

    auto l = root->left;
    auto r = root->right;

    root->right = invertTree( l );
    root->left = invertTree( r );

    return root;
}
\end{lstlisting}