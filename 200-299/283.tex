\section{283 --- Move Zeroes}
Given an array $A$, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.

\paragraph{Example:}

\begin{flushleft}
\textbf{Input}: $[0,1,0,3,12]$
\\
\textbf{Output}: $[1,3,12,0,0]$
\end{flushleft}

\paragraph{Note:}

\begin{itemize}
\item You must do this in-place without making a copy of the array.
\item Minimize the total number of operations.
\end{itemize}
\subsection{In-place Swap}
类似于快速排序算法中的partition，用一个index $x$表示上次和零互换的位置，初始化为零。然后遇到非零的number，就将该number和$A[x]$互换，同时increments $x$。
\setcounter{algorithm}{0}
\begin{algorithm}[H]
\caption{In-Place Swap}
\begin{algorithmic}[1]
\Procedure{MoveZeros}{$A, L$}
\State $x:=0$
\For{$i:=0$ \textbf{to} $L-1$}
\If{$A[i]\neq 0$}
\State $\star$ Swap $A[i]$ and $A[x]$
\State $x\gets x+1$
\EndIf
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
\setcounter{lstlisting}{0}
\begin{lstlisting}[style=customc,caption={In-Place Swap}]
void moveZeroes( vector<int>& nums )
{
    int x = 0;

    for( size_t i = 0; i < nums.size(); ++i )
    {
        if( nums[i] != 0 )
        {
            swap( nums[i], nums[x] );
            ++x;
        }
    }
}
\end{lstlisting}