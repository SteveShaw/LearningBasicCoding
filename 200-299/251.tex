\section{251 --- Flatten 2D Vector}
Design and implement an iterator to flatten a 2d vector. It should support the following operations: \fcj{next} and \fcj{hasNext}.

\paragraph{Example:}

\begin{flushleft}
\fcj{Vector2D iterator = new Vector2D([[1,2],[3],[4]]);}

\fcj{iterator.next(); // return 1}

\fcj{iterator.next(); // return 2}

\fcj{iterator.next(); // return 3}

\fcj{iterator.hasNext(); // return true}

\fcj{iterator.hasNext(); // return true}

\fcj{iterator.next(); // return 4}

\fcj{iterator.hasNext(); // return false}
\end{flushleft}

\paragraph{Follow up:}
\begin{itemize}
\item As an added challenge, try to code it using only iterators in \texttt{C++} or iterators in \texttt{Java}.
\end{itemize}

\subsection{Iterator}
将$x$定义为row的iterator，再用另外一个变量$z$指向二维数组的末尾，同时定义一个整型变量$y$来指向列位置
\setcounter{lstlisting}{0}
\begin{lstlisting}[style=customc, caption={Iterator}]
class Vector2D
{
public:
    Vector2D( vector<vector<int>>& v )
    {
        x = v.begin();
        endV = v.end();
        if( x != endV )
        {
            y = x->begin();
        }
    }
    int next()
    {
        if( !hasNext() )
        {
            //make sure we have next
            return -1;
        }
        int n = *y;
        ++y;
        return n;
    }
    bool hasNext()
    {
        //we need a loop here
        //to skip empty vectors
        while( ( x != endV ) && ( y == x->end() ) )
        {
            ++x;
            if( x != endV )
            {
                y = x->begin();
            }
        }
        return x != endV;
    }
private:
    vector<vector<int>>::iterator x;
    vector<vector<int>>::iterator endV;
    vector<int>::iterator y;
};
\end{lstlisting}