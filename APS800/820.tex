\section{820 --- Short Encoding of Words}

\textbf{Medium}

Given a list of words, we may encode it by writing a reference string $S$ and a list of indexes $A$.

For example, if the list of words is 

\fcj{["time", "me", "bell"]}, 

we can write it as 

\fcj{S = "time#bell#"} and \fcj{indexes = [0, 2, 5]}.

Then for each index, we will recover the word by reading from the reference string from that index until we reach a \fcj{"#"} character.

What is the length of the shortest reference string $S$ possible that encodes the given words?

\paragraph{Example:}

\begin{flushleft}
	\textbf{Input}: \fcj{words = ["time", "me", "bell"]}

\textbf{Output}: 10

\textbf{Explanation}: 

\fcj{S = "time#bell#"} and \fcj{indexes = [0, 2, 5]}.
\end{flushleft}

 

\paragraph{Note:}

\begin{itemize}
	\item  \fcj{1 <= words.length <= 2000}.
    \item \fcj{1 <= words[i].length <= 7}.
    \item \fcj{Each word has only lowercase letters}.
\end{itemize}

\subsection{Store Prefix}
If a word $X$ is a suffix of $Y$, then it does not need to be considered, as the encoding of $Y$ in the reference string will also encode X. For example, if \fcj{"me"} and \fcj{"time"} is in words, we can throw out \fcj{"me"} without changing the answer.

If a word $Y$ does not have any other word $X$ (in the list of words) that is a suffix of $Y$, then Y must be part of the reference string.

Thus, the goal is to remove words from the list such that no word is a suffix of another. 

\setcounter{lstlisting}{0}
\lstinputlisting[style=customc, caption={Remove Suffix}]{820.cpp}

