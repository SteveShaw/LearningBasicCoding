\section{35 --- Search Insert Position}
Given a sorted array $A$ and a target value $T$, return the index if the $T$ is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

\paragraph{Example 1:}

\begin{flushleft}
\textbf{Input}: $[1,3,5,6]$, 5

\textbf{Output}: 2

\end{flushleft}

\paragraph{Example 2:}

\begin{flushleft}
\textbf{Input}: $[1,3,5,6]$, 2

\textbf{Output}: 1
\end{flushleft}

\paragraph{Example 3:}

\begin{flushleft}
\textbf{Input}: $[1,3,5,6]$, 7

\textbf{Output}: 4
\end{flushleft}

\paragraph{Example 4:}

\begin{flushleft}
Input: $[1,3,5,6]$, 0
Output: 0
\end{flushleft}

\subsection{Rightmost Binary Search}
找到第一个大于target的数字所在的位置，这个位置就是该数字需要插入的位置。

\setcounter{lstlisting}{0}
\begin{lstlisting}[style=customc, caption={Rightmost Binary Search}]
int searchInsert( vector<int>& nums, int target )
{
    if( nums.empty() )
    {
        return 0;
    }

    int l = 0;
    int L = static_cast<int>( nums.size() );
    int r = L;

    //rightmost search
    //find the first item that is
    //larger than target
    while( l < r )
    {
        int mid = ( l + r ) / 2;

        if( nums[mid] <= target )
        {
            l = mid + 1;
        }
        else
        {
            r = mid;
        }
    }

    if( ( l > 0 ) && ( nums[l - 1] == target ) )
    {
        return l - 1;
    }

    return l;
}

\end{lstlisting}