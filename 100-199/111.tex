\section{111 --- Minimum Depth of Binary Tree}
Given a binary tree $T$, find its minimum depth.
\par
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
\par
Note: A leaf is a node with no children.
\paragraph{Example:}
\begin{flushleft}
Given binary tree
\begin{figure}[H]
\begin{tikzpicture}
[mynode/.style={draw,circle,minimum size=10mm, fill=gray!20!}]
\node(){};
\node[mynode](3) {3};
\node[mynode](9) [below = 8mm of 3, xshift=-10mm] {9};
\node[mynode](20) [below = 8mm of 1, xshift=10mm] {20};
\node[mynode](15) [below = 8mm of 20, xshift=-6mm] {15};
\node[mynode](7) [below = 8mm of 20, xshift=6mm] {7};
\draw[>=stealth,->] (3) -- (9);
\draw[>=stealth,->] (3) -- (20);
\draw[>=stealth,->] (20) -- (15);
\draw[>=stealth,->] (20) -- (7);
\end{tikzpicture}
\end{figure}
return its minimum depth: 2.
\end{flushleft}
\subsection{Depth First Search}
We incorporate find balance into calculate depth. If we find each node has unbalanced left and right child tree, we return a negative number.

\setcounter{lstlisting}{0}
\begin{lstlisting}[style=customc, caption={DFS}]
bool isBalanced( TreeNode* root )
{
    auto res = depth( root );
    return res >= 0;
}
//helper function to find depth of a node
//we incorprate into comparing depth of left and right
//child tree
//when it is not balance,
//return -1
int depth( TreeNode* node )
{
    if( !node )
    {
        return 0;
    }
    int l_dep = depth( node->left );
    if( l_dep < 0 )
    {
        return -1;
    }

    int r_dep = depth( node->right );
    if( r_dep < 0 )
    {
        return -1;
    }
    //check if left and right child tree
    //are balanced
    int diff = abs( l_dep - r_dep );
    if( diff > 1 )
    {
        //unbalanced
        return -1;
    }
    //balanced
    //return the depth
    return ( max )( l_dep, r_dep ) + 1;
}
\end{lstlisting}
