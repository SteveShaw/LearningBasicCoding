\section{111 --- Minimum Depth of Binary Tree}
Given a binary tree $T$, find its minimum depth.
\par
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
\par
Note: A leaf is a node with no children.
\paragraph{Example:}
\begin{flushleft}
Given binary tree
\begin{figure}[H]
\begin{tikzpicture}
[mynode/.style={draw,circle,minimum size=10mm, fill=gray!20!}]
\node(){};
\node[mynode](3) {3};
\node[mynode](9) [below = 8mm of 3, xshift=-10mm] {9};
\node[mynode](20) [below = 8mm of 1, xshift=10mm] {20};
\node[mynode](15) [below = 8mm of 20, xshift=-6mm] {15};
\node[mynode](7) [below = 8mm of 20, xshift=6mm] {7};
\draw[>=stealth,->] (3) -- (9);
\draw[>=stealth,->] (3) -- (20);
\draw[>=stealth,->] (20) -- (15);
\draw[>=stealth,->] (20) -- (7);
\end{tikzpicture}
\end{figure}
return its minimum depth: 2.
\end{flushleft}
\subsection{Depth First Search}
\begin{CJK*}{UTF8}{gbsn}
如果当前节点是叶子节点，返回1，如果是空节点，返回0。如果有左节点，则递归计算左子树的最小深度，如果有右节点，递归计算右子树的最小深度。然后如果左节点和右节点都为非空节点，则取左右子树两个深度中最少的那个。
\end{CJK*}
\subsubsection{Algorithm}
\setcounter{algorithm}{0}
\begin{algorithm}[H]
\caption{Depth First Search}
\begin{algorithmic}[1]
\Procedure{MinDepth}{$T$}
\If{$T=\texttt{null}$}
\State \Return 0
\EndIf
\If{$\texttt{LEFT}(T)=\texttt{null}$ \textbf{and} $\texttt{RIGHT}(T)=\texttt{null}$}
\State \Return 1
\EndIf
\State $\texttt{ans}:=+\infty$
\If{$\texttt{LEFT}(T)\neq \texttt{null}$}
\State $\texttt{ans}\gets \min(\texttt{ans}, \texttt{MinDepth}(\texttt{LEFT}(T))$
\EndIf
\If{$\texttt{RIGHT}(T)\neq \texttt{null}$}
\State $\texttt{ans}\gets \min(\texttt{ans}, \texttt{MinDepth}(\texttt{RIGHT}(T))$
\EndIf
\State \Return $1+\texttt{ans}$
\EndProcedure
\end{algorithmic}
\end{algorithm}
