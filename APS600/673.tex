\section{673 --- Number of Longest Increasing Subsequence}
Given an unsorted array of integers, $A$,  find the number of longest increasing subsequence.

\paragraph{Example 1:}
\begin{flushleft}


\textbf{Input}: \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|[1,3,5,4,7]|

\textbf{Output}: 2

\textbf{Explanation}: The two longest increasing subsequence are \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|[1, 3, 4, 7]| and \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|[1, 3, 5, 7]|.
\end{flushleft}

\paragraph{Example 2:}
\begin{flushleft}


\textbf{Input}: \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|[2,2,2,2,2]|

\textbf{Output}: 5

\textbf{Explanation}: 

The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.
\end{flushleft}

\paragraph{Note:} 
\begin{itemize}
\item Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|signed int|.
\end{itemize}

\subsection{Segment Tree}
Many problems require that we give results based on query over a range or segment of available data. This can be a tedious and slow process, especially if the number of queries is large and repetitive. A segment tree let's us process such queries efficiently in logarithmic order of time.

Segment Trees have applications in areas of computational geometry and geographic information systems. For example, we may have a large number of points in space at certain distances from a central reference/origin point. Suppose we have to lookup the points which are in a certain range of distances from our origin. An ordinary lookup table would require a linear scan over all the possible points or all possible distances (think hash-maps). Segment Trees lets us achieve this in logarithmic time with much less space cost. Such a problem is called Planar Range Searching. Solving such problems efficiently is critical, especially when dealing with dynamic data which changes fast and unpredictably (for example, a radar system for air traffic.)

A segment tree is a binary tree where each node represents an interval. Generally a node would store one or more properties of an interval which can be queried later.

A typical example of using segment tree is \textbf{Range Sum Query}. Suppose we are given an array $A$ with size $n$

\begin{enumerate}
\item The root of the segment tree typically represents the entire interval of data. This would be $A[0:n-1]$.
\item Each leaf of the tree represents a range comprising of just a single element. Thus the leaves represent $A[0]$, $A[1]$ and so on until $A[n-1]$.
\item The internal nodes of the tree would represent the \textbf{merged} or \textbf{union} result of their children nodes.
\item Each of the children nodes could represent approximately half of the range represented by their parent.
\end{enumerate}

A segment tree for an $n$ element range can be represented using an array of size $\approx 4\times n$. This ensures that the built segment tree as a complete binary tree, which in turn ensures that the height of the tree is upper-bounded by the logarithm of the size of our input.

The segment tree algorithm include three methods: \textbf{build}, \textbf{query} and \textbf{update}.

\begin{enumerate}
\item \textbf{build}: Build the tree from the original data
\setcounter{lstlisting}{0}
\begin{lstlisting}[style=customc, caption={Build}]
// call this method as build(arr, 0, 0, n-1);
// Here A[] is input array and n is its size.

void buildSegTree( vector<int>& A, int treeIndex, int lo, int hi )
{
    if( lo == hi )
    {
        // leaf node. store value in node.
        tree[treeIndex] = A[lo];
        return;
    }

    int mid = lo + ( hi - lo ) / 2; // recurse deeper for children.

    //build left tree
    buildSegTree( A, 2 * treeIndex + 1, lo, mid );

    //build right tree
    buildSegTree( A, 2 * treeIndex + 2, mid + 1, hi );

    // merge build results
    tree[treeIndex] = merge( tree[2 * treeIndex + 1], tree[2 * treeIndex + 2] );
}
\end{lstlisting}
The method builds the entire tree in a bottom up fashion. When the condition \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|lo = hi| is satisfied, we are left with a range comprising of just a single element (which happens to be \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|A[lo]|). This constitutes a leaf of the tree. The rest of the nodes are built by merging the results of their two children. \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|treeIndex| is the index of the current node of the segment tree which is being processed.
\item \textbf{query}: Read/Query on an interval or segment of the data.

\begin{lstlisting}[style=customc, caption={Query/Read}]
// call this method as query(tree, 0, 0, n-1, i, j);
// Here [i,j] is the range/interval we are querying.
// This method relies on "null" nodes being equivalent to storing zero.
int query( vector<int>& tree, int treeIndex, int lo, int hi, int i, int j )
{
    // query for arr[i..j]

    if( lo > j || hi < i )
    {
        // segment completely outside range
        return 0; // represents a null node
    }

    if( i <= lo && j >= hi )
    {
        // segment completely inside range
        return tree[treeIndex];
    }

    // partial overlap of current segment and queried range.
    // Recurse deeper.
    int mid = lo + ( hi - lo ) / 2;

    if( i > mid )
    {
        return query( tree, 2 * treeIndex + 2, mid + 1, hi, i, j );
    }
    else if( j <= mid )
    {
        return query( tree, 2 * treeIndex + 1, lo, mid, i, j );
    }

    int leftQuery = query( tree, 2 * treeIndex + 1, lo, mid, i, mid );

    int rightQuery = query( tree, 2 * treeIndex + 2, mid + 1, hi, mid + 1, j );

    // merge query results
    return merge( leftQuery, rightQuery );
}
\end{lstlisting}
The method returns a result when the queried range matches exactly with the range represented by a current node. Else it digs deeper into the tree to find nodes which match a portion of the node exactly.

\item \textbf{update}: Update the value of an element.

\begin{lstlisting}[style=customc, caption={Update}]
// call this method as update(tree, 0, 0, n-1, i, val);
// Here you want to update the value at index i with value val.
void update( vector<int>& tree, int treeIndex, int lo, int hi, int arrIndex, int val )
{
    if( lo == hi )
    {
        // leaf node. update element.
        tree[treeIndex] = val;
        return;
    }

    // recurse deeper for appropriate child
    int mid = lo + ( hi - lo ) / 2;

    if( arrIndex > mid )
    {
        update( tree, 2 * treeIndex + 2, mid + 1, hi, arrIndex, val );
    }
    else if( arrIndex <= mid )
    {
        update( 2 * treeIndex + 1, lo, mid, arrIndex, val );
    }

    // merge updates
    tree[treeIndex] = merge( tree[2 * treeIndex + 1], tree[2 * treeIndex + 2] );
}
\end{lstlisting}
This is similar to \textbf{build}. We update the value of the leaf node of our tree which corresponds to the updated element. Later the changes are propagated through the upper levels of the tree straight to the root.
\end{enumerate}

\subsubsection{Lazy Propagation}
What we have been discussing is updating single elements only. That happens in logarithmic time and it's pretty efficient.

But what if we had to update a range of elements? By current method, each element would have to be updated independently. This will incur some run time cost.

The construction of a tree poses another issue called \textbf{ancestral locality}. Ancestors of adjacent leaves are guaranteed to be common at some levels of the tree. Updating each of these leaves individually would mean that we process their common ancestors multiple times. 

Another problem is that queried ranges do not contain frequently updated elements. We might be wasting time updating nodes which are rarely going to be accessed/read.

Using \textbf{Lazy Propagation} allows us to overcome all of these problems by reducing wasteful computations and processing nodes on-demand.

As the name suggests, we update nodes lazily. In short, we try to postpone updating descendants of a node, until the descendants themselves need to be accessed.

For the purpose of applying it to the \textbf{Range Sum Query} problem, we assume that the \textbf{update} operation on a range, increments each element in the range by some amount $x$.

We use another array \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|lazy[]| which is the same size as our segment tree array \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|tree[]| to represent a lazy node. \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|lazy[i]| holds the amount by which the node \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|tree[i]| needs to be incremented, when that node is finally accessed or queried. When \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|lazy[i]| is zero, it means that node \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|tree[i]| is not lazy and has no pending updates.

\paragraph{Updating a range lazily}

This is a three step process:

\begin{enumerate}
\item Normalize the current node. This is done by removing laziness. We simply increment the current node by appropriate amount to remove it's laziness. Then we mark its children to be lazy as the descendants haven't been processed yet.
\item Apply the current update operation to the current node if the current segment lies inside the update range.
\item Recurse for the children as you would normally to find appropriate segments to update.
\end{enumerate}

\begin{lstlisting}[style=customc, caption={Update Lazily}]
//call this method as updateLazily(0,0,n-1,range_start,range_end, val);
//here we want to update the range [range_start, range_end] with value (val)
void updateLazily( int treeIndex, int lo, int hi, int range_start, int range_end, int val )
{
    if( lazy[treeIndex] != 0 )
    {
        //this node is lazy
        //normalize current node by removing laziness
        tree[treeIndex] += ( hi - lo + 1 ) * lazy[treeIndex];

        if( lo != hi )
        {
            //update lazy[] for children
            lazy[2 * treeIndex + 1] += lazy[treeIndex];
            lazy[2 * treeIndex + 2] += lazy[treeIndex];
        }

        //current node is processed
        //no longer lazy
        lazy[treeIndex] = 0;
    }

    if( ( lo > hi ) || ( lo > range_end ) || ( hi < range_start ) )
    {
        //out of range
        return;
    }

    if( ( range_start <= lo ) && ( hi <= range_end ) )
    {
        //segement is fully within the update range
        //update segment
        tree[treeIndex] += ( hi - lo + 1 ) * val;

        if( lo != hi )
        {
            //update lazy[] for children
            lazy[2 * treeIndex + 1] += val;
            lazy[2 * treeIndex + 2] += val;
        }

        return;
    }

    int mid = lo + ( hi - lo ) / 2;

    //recurse deeper for appropriate child
    updateLazily( 2 * treeIndex + 1, lo, mid, range_start, range_end, val );
    updateLazily( 2 * treeIndex + 1, mid + 1, hi, range_start, range_end, val );

    //merge updates
    tree[treeIndex] = tree[2 * treeIndex + 1] + tree[2 * treeIndex + 2];
}
\end{lstlisting}

\paragraph{Querying a lazily propagated tree}

This is a two step process:
\begin{enumerate}
\item Normalize the current node by removing laziness. This step is the same as the \textbf{update} step.
\item Recursively deep into the children to find appropriate segments which fit in queried range.
\end{enumerate}

\begin{lstlisting}[style=customc, caption={Query Lazily}]
// call this method as queryLazily(0, 0, n-1, range_start, range_end);
// Here [range_start, range_end] is the range/interval we are querying.
// This method relies on "null" nodes being equivalent to storing zero.
int queryLazily( int treeIndex, int lo, int hi, int range_start, int range_end )
{
    //query for original array A[range_start, range_end]
    if( ( lo > range_end ) || ( hi < range_start ) )
    {
        //segment is completely outside range
        //return a value represent null node
        return 0;
    }

    if( lazy[treeIndex] )
    {
        //this node is lazy
        //normalize current node by removing laziness
        tree[treeIndex] += ( hi - lo + 1 ) * lazy[treeIndex];

        if( lo != hi )
        {
            //update lazy[] for children nodes
            lazy[2 * treeIndex + 1] += lazy[treeIndex];
            lazy[2 * treeIndex + 2] += lazy[treeIndex];
        }

        //current node is processed
        //it is no longer lazy
        lazy[treeIndex] = 0;
    }

    if( ( range_start <= lo ) && ( hi <= range_end ) )
    {
        //segment is completely inside the query range
        //return the node
        return tree[treeIndex];
    }

    //otherwise, segement is overlap with query range
    int mid = ( hi + lo ) / 2;

    if( range_start > mid )
    {
        return queryLazily( treeIndex * 2 + 1, mid + 1, hi, range_start, range_end );
    }
    else if( range_end <= md )
    {
        return queryLazily( treeIndex * 2 + 2, lo, mid, range_start, range_end );
    }

    int leftQuery = queryLazily( 2 * treeIndex + 1, lo, mid, range_start, mid );
    int rightQuery = queryLazily( 2 * treeIndex + 2, mid + 1, hi, mid + 1, range_end );

    //merge query results
    return leftQuery + rightQuery;
}
\end{lstlisting}

\paragraph{Note:} The following lines:

\begin{lstlisting}[style=customc, caption={Notes}]
// normalize current node by removing laziness
tree[treeIndex] += ( hi - lo + 1 ) * lazy[treeIndex];

// update segment
tree[treeIndex] += ( hi - lo + 1 ) * val;

// merge updates
tree[treeIndex] = tree[2 * treeIndex + 1] + tree[2 * treeIndex + 2];
\end{lstlisting}

are specific to the \textbf{Range Sum Query} problem. Different problems may have their own updating and merging schemes.