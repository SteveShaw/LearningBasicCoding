\section{659 --- Split Array into Consecutive Subsequences}
Given an array $A$ sorted in ascending order, return \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|true| if and only if you can split it into 1 or more subsequences such that each subsequence consists of consecutive integers and has length at least 3.

\paragraph{Example 1:}

\begin{flushleft}
\textbf{Input}: \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|[1,2,3,3,4,5]|

\textbf{Output}: \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|true|

\textbf{Explanation}:

You can split them into two consecutive subsequences:
 
\lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|1, 2, 3|

\lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|3, 4, 5|

\end{flushleft}

\paragraph{Example 2:}

\begin{flushleft}
\textbf{Input}: \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|[1,2,3,3,4,4,5,5]|

\textbf{Output}: \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|true|

\textbf{Explanation}:

You can split them into two consecutive subsequences : 

\lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|1, 2, 3, 4, 5|

\lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|3, 4, 5|

\end{flushleft}

\paragraph{Example 3:}

\begin{flushleft}
\textbf{Input}: \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|[1,2,3,4,4,5]|


\textbf{Output}: \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|false|
\end{flushleft}

 

\paragraph{Constraints:}

\begin{itemize}
\item  $ 1 \leq \lvert A\rvert \leq 10000$
\end{itemize}

\subsection{Opening and Closing Events}
We can think of the problem as drawing intervals on a number line. This gives us the idea of opening and closing events.

To illustrate this concept, say we have \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|A = [10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13]|. There are two sequences start at 10, two start at 11, and three end at 12.

In general, for a number $x$, suppose $z = \delta(x+1)-\delta(x)$ where $\delta(x)$ is the count of number $x$, we will have

\begin{enumerate}
\item $z > 0$: there will be $z$ sequences starting from $x+1$.
\item $z<0$: there are $\lvert z\rvert$ sequences ending at $x$
\item $z =0$: continue current sequence. No any opening or closing event happen.
\end{enumerate}

Take the above example, $\delta(11) - \delta(10)=2$ and $\delta(13) - \delta(12)=-3$. Thus, we have two sequences starting from 11 and three sequences ending at 12.

Another thing we should notice: for example, if some sequences starting from 1 and 4, and some other sequences ending at 5 and 7, to maximize the length of the sequences with minimum length (because the minimum size of the sequence is 3), we should pair the events together in the order they occur: i.e., 1 with 5 and 4 with 7.

\paragraph{Algorithm}

We make use of a queue $Q$ to track current starting numbers of a possible sequence. Suppose current number is $x$ and $x_0$ is the one close to $x$ in the given array such that $x_0+1\leq x$. 

\begin{itemize}
\item Binary search the first number that is larger than $x$ in given array, say $y$. Then, from the indices of $y$ and $x$, we can know the count of $x$, say $\delta(x)$ in the array.
\item If $x\neq x_0+1$, closing events happens at number $x_0$. 
\begin{enumerate}
\item We will check $x_0$ against elements in $Q$ by $\delta(x_0)$ times because we have $\delta(x_0)$ sequences ending at $x_0$. 

Each time, we get and remove the front element from $Q$, say $t$. If $x_0 -t < 2$, this means the sequence starting with $t$ and ending at $x_0$ will have a length less than 3, this violates the requirement. Therefore, we can return \lstinline[language=C++, basicstyle=\small\ttfamily, keywordstyle=\bfseries\color{green!40!black}]|false|.

Otherwise, we continue this process by $\delta(x_0)$ times
\item Then, we push $x$ into $Q$ by $\delta(x)$ times because these $x$ are start numbers of some sequences.
\end{enumerate}
\item If $x=x_0+1$, as the above discussion, we know that
\begin{enumerate}
\item if $\delta(x_0) > \delta(x)$, there will be $z=\delta(x_0)-\delta(x)$ sequences ending at $x_0$, i.e $z$ closing events for $x_0$. Thus, we will perform the same closing event operation for $x_0$ excepting pushing $x$ into $Q$.
\item If $\delta(x_0)<\delta(x)$, there will be $z=\delta(x)-\delta(x_0)$ sequence starting from $x$, i.e., $z$ opening events for $x$. Thus, we enqueue $x$ into $Q$ by $z$ times.
\end{enumerate}
\item In the end, we will check the ending events on the last element of the array if possible.
\end{itemize}

\subsection{Greedy}
The basic idea is that, for each distinct element $x$ in the input array, we only need to maintain three variables, i.e., the number of consecutive sub-sequences ending at $x$e with length of 1, 2 and no less than 3.

Suppose $x$ is the current number we are processing, and it appears $z$ times in the array. We also assume $x_0$ is the number we have processed immediately before $x$, and $z_0$ is the count of its appearance. 

We denote the The number of consecutive sub-sequences ending at $x_0$ with length 1, 2 and no less than 3 are $\ell_1$, $\ell_2$ and $\ell_3$ respectively.

Then, we have two scenarios
\begin{enumerate}
    \item $x\neq x_0+1$: in this case, we cannot add $x$ to any consecutive subsequence ending at $x_0$. Thus $\ell_1=\ell_2=0$ (the consecutive sequence ending at $x_0$ with length 1 and 2). Suppose $t_1$, $t_2$ and $t_3$ are number of consecutive sub-sequences ending at $x$ with length 1, 2 and no less than 3, we will have $t_1=z$, $t_2=0$ and $t_3=0$, which means we only have $z$ consecutive subsequence with length 1 ending at $x$.
    \item $x=x_0+1$. This allows us to add $x$ to consecutive sub-sequences ending at $x_0$ and thus extend those sub-sequences. 
    But we should add these $x$s to those sub-sequences with length 1 first, and length 2 secondly, and finally to those with length larger than 2. We also need $z\geq \ell_1+\ell_2$. If this condition is violated, some consecutive sequences will extend length over 2. 
    As in first case, we use $t_1$, $t_2$ and $t_3$ to represent the number of consecutive sub-sequences ending at $x$ with length of 1, 2 and over 2 respectively. We can get following relationships
    \begin{align*}
        t_2 &= \ell_1 \\
        t_3 &= \ell_2 + \min(\ell_3, z-(\ell_1+\ell_2)) \\
        t_2 &= \max(z - (\ell_1+\ell_2+\ell_3), 0)
    \end{align*}
    Since we add $x$ to the consecutive sub-sequence ending at $x_0$ with length 1 firstly, the consecutive sub-sequence ending $x$ will have length 2. Thus, $t_2 \gets \ell_1$.
    
    Next, we add remaining $x$ to those consecutive sub-sequences ending at $x_0$ with length2. These will give consecutive sub-sequences ending at $x$ with length 3. Thus, $t_3\geq \ell_2$. If $z > ell_1 + ell_2$, we still have some $x$ to use and can add them to the subsequences ending at $x_0$ with length over 2. All these subsequences ending at $x$ have length over 2, and the total number of such subsequences is $\ell_2 + \min(\ell_3, z - (\ell_1 + \ell_2))$. 
    
    If $z > \ell_1 + \ell_2 + \ell_3$, we still have remaining $x$s will form the sub-sequences ending at $x$ with length 1, and thus $t_1 = \max(z - (\ell_1 + \ell_2 + \ell_3), 0)$.
\end{enumerate}

After $x$ is processed, we will update $\ell_i$ by $t_i$ where $i=1,2,3$, and $x_0$ by $x$. Finally, if we get $\ell_1=0$ and $\ell_2=0$, we can split the array into consecutive parts. Otherwise, it cannot be done.



