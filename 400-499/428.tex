\section{428 --- Serialize and Deserialize N-ary Tree}
\textcolor{red}{Locked}
\\
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
\par
Design an algorithm to \textbf{serialize} and \textbf{deserialize} an $N$-ary tree. An $N$-ary tree is a rooted tree in which each node has no more than $N$ children. There is no restriction on how your \textbf{serialization}/\textbf{deserialization} algorithm should work. You just need to ensure that an $ N $-ary tree can be serialized to a string and this string can be deserialized to the original tree structure.

For example, you may serialize the following 3-ary tree

\begin{figure}[H]
\begin{tikzpicture}
[my/.style={draw, circle, minimum size=7mm, fill=gray!20!}]
\node[my](0) at (0,0) {1};
\node[my](1) [below=8mm of 0, xshift=-12mm] {3};
\node[my](2) [below=8mm of 0] {2};
\node[my](3) [below=8mm of 0, xshift=12mm] {4};
\node[my](4) [below=8mm of 1, xshift=-10mm] {5};
\node[my](5) [below=8mm of 1, xshift=10mm] {6};
\draw[thick] (0)--(1)--(4);
\draw[thick] (1)--(5);
\draw[thick] (0)--(2);
\draw[thick] (0)--(3);
\end{tikzpicture}
\end{figure}
as [1 [3[5 6] 2 4]]. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

\paragraph{Note:}
\begin{itemize}
\item $ N $ is in the range of $[1, 1000]$
\item Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
\end{itemize}

\subsection{Preorder Traverse}
\begin{itemize}
\item Serialize: 
\begin{enumerate}
\item Fo a null node, add a special character like \#
\item Otherwise, add the node's value first, then add a space, and then the number of its children, and then add a space again.
\item If it has children, recursively traverse into each child node, do the above operation again.
\end{enumerate}
\item Deserialize: We may need \texttt{istringstream} to help read the string as a input stream.
\begin{enumerate}
\item Read the value from the stream. If the special character is the value, return the null node.
\item Otherwise, read the number of children from the stream. 
\item Create a new node with read value.
\item By the number of children, we add a recursively-built node into the children array of current node.
\item Finally, return the current node
\end{enumerate}
\end{itemize}

\setcounter{lstlisting}{0}
\begin{lstlisting}[style=customc, caption={Recursion}]
/*
class Node
{
public:
    int val;
    vector<Node*> children;

    Node()
    {}
}
*/
// Encodes a tree to a single string.
string serialize( Node* root )
{
    string tree;
    preorder( root, tree );
    return tree;
}

void preorder( Node* node, string& stree )
{
    if( !node )
    {
        stree.push_back( '#' );
    }

    //val + space + number of children + space
    stree += to_string( node->val );
    stree.push_back( ' ' );

    if( node->children.empty() )
    {
        stree.push_back( '0' );
        stree.push_back( ' ' );
    }
    else
    {
        stree += to_string( node->children.size() );
        stree.push_back( ' ' );

        for( auto child : node->children )
        {
            //recursively serialize the child
            preorder( child, stree );
        }
    }

    return;

}

// Decodes your encoded data to tree.
Node* deserialize( string data )
{
    std::istringstream iss( data );
    return build( iss );
}

Node* build( std::istringstream& iss )
{
    string sval;
    string slen;

    //read value first
    iss >> sval;

    if( sval[0] == '#' )
    {
        return nullptr;
    }

    //read lenth then
    iss >> slen;

    int val = stoi( sval );

    //create the new node
    Node* node = new Node();
    node->val = val;

    int len = stoi( slen );

    if( len > 0 )
    {
        for( int i = 0; i < len; ++i )
        {
            //recursively build child
            //add child into node->children
            node->children.push_back( build( iss ) );
        }
    }
    return node;
}
\end{lstlisting}
